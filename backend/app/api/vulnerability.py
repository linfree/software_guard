from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional, Generic, TypeVar
from pydantic import BaseModel

from ..core.database import get_db
from ..core.deps import require_ops
from ..models.user import User
from ..models.vulnerability import Vulnerability
from ..schemas.vulnerability import VulnerabilityCreate, VulnerabilityUpdate, VulnerabilityResponse, VulnerabilityWithSoftwareResponse

router = APIRouter(prefix="/vulnerabilities", tags=["漏洞管理"])

T = TypeVar('T')


class PaginatedResponse(BaseModel, Generic[T]):
    """通用分页响应模型"""
    total: int
    items: List[T]


@router.post("", response_model=VulnerabilityResponse, status_code=status.HTTP_201_CREATED)
async def create_vulnerability(
    vuln_data: VulnerabilityCreate,
    current_user: User = Depends(require_ops),
    db: Session = Depends(get_db)
):
    """创建漏洞记录"""
    # 验证严重程度
    valid_severities = ["critical", "high", "medium", "low"]
    if vuln_data.severity not in valid_severities:
        raise HTTPException(
            status_code=400,
            detail=f"无效的严重程度，必须是: {', '.join(valid_severities)}"
        )

    vulnerability = Vulnerability(
        software_id=vuln_data.software_id,
        cve_id=vuln_data.cve_id,
        severity=vuln_data.severity,
        title=vuln_data.title,
        description=vuln_data.description,
        affected_versions=vuln_data.affected_versions,
        fixed_version=vuln_data.fixed_version,
        reference_url=vuln_data.reference_url
    )
    db.add(vulnerability)
    db.commit()
    db.refresh(vulnerability)

    return vulnerability


@router.get("", response_model=PaginatedResponse[VulnerabilityWithSoftwareResponse])
async def list_vulnerabilities(
    software_id: Optional[int] = None,
    severity: Optional[str] = None,
    skip: int = 0,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """获取漏洞列表"""
    from sqlalchemy.orm import joinedload
    from ..models.software import Software

    query = db.query(Vulnerability).options(joinedload(Vulnerability.software))

    if software_id:
        query = query.filter(Vulnerability.software_id == software_id)
    if severity:
        query = query.filter(Vulnerability.severity == severity)

    # 获取总数
    total = query.count()

    vulnerabilities = query.order_by(Vulnerability.created_at.desc())\
        .offset(skip)\
        .limit(limit)\
        .all()

    # 构造包含软件名称的响应
    result = []
    for vuln in vulnerabilities:
        vuln_dict = vuln.__dict__.copy()
        vuln_dict['software_name'] = vuln.software.name if vuln.software else "未知软件"
        result.append(vuln_dict)

    return PaginatedResponse(total=total, items=result)


@router.put("/{vulnerability_id}", response_model=VulnerabilityResponse)
async def update_vulnerability(
    vulnerability_id: int,
    vuln_data: VulnerabilityUpdate,
    current_user: User = Depends(require_ops),
    db: Session = Depends(get_db)
):
    """更新漏洞记录"""
    vulnerability = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
    if not vulnerability:
        raise HTTPException(status_code=404, detail="漏洞不存在")

    # 验证严重程度
    if vuln_data.severity:
        valid_severities = ["critical", "high", "medium", "low"]
        if vuln_data.severity not in valid_severities:
            raise HTTPException(
                status_code=400,
                detail=f"无效的严重程度，必须是: {', '.join(valid_severities)}"
            )

    # 更新字段
    if vuln_data.software_id is not None:
        vulnerability.software_id = vuln_data.software_id
    if vuln_data.cve_id is not None:
        vulnerability.cve_id = vuln_data.cve_id
    if vuln_data.severity is not None:
        vulnerability.severity = vuln_data.severity
    if vuln_data.title is not None:
        vulnerability.title = vuln_data.title
    if vuln_data.description is not None:
        vulnerability.description = vuln_data.description
    if vuln_data.affected_versions is not None:
        vulnerability.affected_versions = vuln_data.affected_versions
    if vuln_data.fixed_version is not None:
        vulnerability.fixed_version = vuln_data.fixed_version
    if vuln_data.reference_url is not None:
        vulnerability.reference_url = vuln_data.reference_url

    db.commit()
    db.refresh(vulnerability)

    return vulnerability


@router.delete("/{vulnerability_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_vulnerability(
    vulnerability_id: int,
    current_user: User = Depends(require_ops),
    db: Session = Depends(get_db)
):
    """删除漏洞记录"""
    vulnerability = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
    if not vulnerability:
        raise HTTPException(status_code=404, detail="漏洞不存在")

    db.delete(vulnerability)
    db.commit()

    return None


@router.get("/check/{software_id}/{version}", response_model=List[VulnerabilityResponse])
async def check_vulnerabilities(
    software_id: int,
    version: str,
    db: Session = Depends(get_db)
):
    """检查指定版本是否存在漏洞"""
    # 简化版本比较，实际应用中应该使用更复杂的版本比较逻辑
    vulnerabilities = db.query(Vulnerability)\
        .filter(Vulnerability.software_id == software_id)\
        .all()

    # 过滤出影响该版本的漏洞
    affected = []
    for vuln in vulnerabilities:
        if vuln.affected_versions:
            # 简单的字符串匹配，实际应该使用语义化版本比较
            if version in vuln.affected_versions or "-" in vuln.affected_versions:
                affected.append(vuln)
        # 如果没有指定修复版本，认为所有版本都受影响
        elif not vuln.fixed_version:
            affected.append(vuln)
        elif vuln.fixed_version and version < vuln.fixed_version:
            affected.append(vuln)

    return affected